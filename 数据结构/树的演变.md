# 树的演变

  本文会和你介绍树的演变过程，从二叉树->二叉查找树->平衡二叉树(AVL树)->b-树->b+树（MySQL索引）->红黑树（BR树，1.8HashMap，这里可以提一下23树，把23树对应红黑树来讲），以上并非是二叉树的演变过程，而是我从复杂程度过来区分的，所有的树都各有各的好处，接下去由我来分别介绍。



## 二叉树

​    我们经常谈论的树，都是以二叉树为起点，然后添加各种规则去实现查找时间或者空间的减少。二叉树，是很平常的一颗“倒过来”的树，单单用来存储数据，如下图，因为不涉及查找，所以数字可以乱放：

![image-20210702001459394](树的演变/image-20210702001459394.png)

  然后我们来手写一个树的类，来模拟一下这个二叉树：很简单，一个树有左右结点，然后值。

```java
public class TreeNode {
    private TreeNode leftTreeNode;
    private TreeNode rightTreeNode;
    private int value;
}

```

然后给上set和构造方法：

```java
public class TreeNode {
    private TreeNode leftTreeNode;
    private TreeNode rightTreeNode;
    private int value;
    public TreeNode(int value) {
        this.value = value;
    }
    public void setLeftTreeNode(TreeNode leftTreeNode) {
        this.leftTreeNode = leftTreeNode;
    }

    public void setRightTreeNode(TreeNode rightTreeNode) {
        this.rightTreeNode = rightTreeNode;
    }
}
```

接下去我们使用它：

```java
public class TreeDemo {
    public static void main(String[] args) {
        TreeNode treeNode1 = new TreeNode(1);
        TreeNode treeNode2 = new TreeNode(2);
        TreeNode treeNode3 = new TreeNode(3);
    }
}
```

  现在的情况如图：

![image-20210702003627430](树的演变/image-20210702003627430.png)

  然后以1作为起点脸上其他结点就变成了我们刚开始看到的图：

```java
   public class TreeDemo {
    public static void main(String[] args) {
        TreeNode treeNode1 = new TreeNode(1);
        TreeNode treeNode2 = new TreeNode(2);
        TreeNode treeNode3 = new TreeNode(3);
        treeNode1.setLeftTreeNode(treeNode2);
        treeNode1.setRightTreeNode(treeNode3);
    }
}
```

  ### 遍历二叉树

  二叉树是一种数据结构，主要还是用来存储数据的，既然树做好了，我们下面来讲讲怎么遍历把，

遍历方法分为三种，以根为划分依据分为：

* 先序遍历：先遍历根结点，然后左节点，右结点。（根左右）
* 中序遍历：先遍历左结点，然后根节点，右结点。（左根右）
* 后序遍历：先遍历左结点，然后右节点，根结点。（左右根）

  一句话，当找到一个新结点时，把这个结点当成新的根，去找他的孩子，如果没有孩子，再去根据选择的遍历顺序取值，我这里举个栗子：

![在这里插入图片描述](树的演变/20190503144011107.png)

```shell
先序遍历：ABDFCEGHI
中序遍历：BFDACHGIE
后序遍历：FDBHIGECA
```

  比如说我这个中序怎么出来的？中序是左根右，那么我们先把根当成第一个结点：

* 根A的左边为B，我们优先进入B。
* 然后B是新的根，B的左边没有数，然后右边是D，我们进入D。此时顺序为：B
* 把D当成新的根，则左子树为F，且F下没有子树了，而根为D，所以得到顺序为:BFD。
* 然后左子树遍历完毕后，回到根，得到A。目前为：BFDA
* 左根右的左和根遍历完了，我们接下去遍历右。
* 进入C，此时的C为新的根，由于没有左子树，所以我们得到C，此时为：BFDAC
* 进入E，E有左子树G，而G也有左子树，所以此时G为新根，左根右，此时为:BFDACHGI

* 返回E，此时E为根，由于左子树遍历完了，所以走根，得到E。此时为:BFDACHGIE

  其他的可以自己再试试，接下来我们来代码实现一下后序遍历：

```java
    public static void LRD(TreeNode rootTreeNode){
        if (rootTreeNode!=null){
            LRD(rootTreeNode.getLeftTreeNode());
            LRD(rootTreeNode.getRightTreeNode());
            System.out.print(rootTreeNode.getValue()+"--");
        }
    }  
```

  然后使用方法遍历它： 

```java
public class TreeDemo {
    public static void main(String[] args) {
        LRD(A);
        System.out.println("author:zsp");
    }
```

  如果需要我代码的同学可以到我github查看：[找数据结构文件夹的src下](https://github.com/270520006/java-advanced)，输出结果如下：

![image-20210702014845452](树的演变/image-20210702014845452.png)

### 动态创建二叉树  

  上面是我们静态创建的二叉树，接下来我们试一下动态创建二叉树（就是不用再去一个个连结点）。

  这里先创建一个根的类：

```java
/**
 * 创建一个TreeRoot来代表根，本质上TreeRoot也还是TreeNode
 */
public class TreeRoot {
    private TreeNode treeRoot;
    public TreeNode getTreeRoot() {
        return treeRoot;
    }
    public void setTreeRoot(TreeNode treeRoot) {
        this.treeRoot = treeRoot;
    }
}
```

  然后进行树的创建编写，大于放右边，小于放左边：

```java
    public static void CreateTree(TreeRoot treeRoot,int  value){
        if (treeRoot.getTreeRoot()==null){ //如果传过来的树根为空，说明是第一个元素
            TreeNode treeNode = new TreeNode(value); //创建树结点，成为第根节点
            treeRoot.setTreeRoot(treeNode);
        }
        else{ //否则，说明是第二个元素
            TreeNode temRoot = treeRoot.getTreeRoot();//创建临时结点，防止出现树下有孩子
            while(treeRoot!=null){ //无限遍历，一直找到叶子结点的下位，就不找了
                if (value>temRoot.getValue()){ //大于放右边
                    if (temRoot.getRightTreeNode()==null){//查看结点是否为叶子结点
                        temRoot.setRightTreeNode(new TreeNode(value));
                        return;
                    }
                    else //有值，说明下面还有结点
                    {
                        temRoot=temRoot.getRightTreeNode();
                    }
                }else //小于放左边
                {
                    if (temRoot.getLeftTreeNode()==null){
                        temRoot.setLeftTreeNode(new TreeNode(value));
                        return;
                    }else{
                        temRoot=temRoot.getLeftTreeNode();
                    }
                }
            }
        }
    }
```

  测试一下：

```java
public class TreeDemo {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(5);//模拟要放入的数据
        list.add(2); list.add(1);list.add(4); list.add(3); list.add(5);
        TreeRoot treeRoot = new TreeRoot();//创建一颗树出来
        for (Integer one : list) { //依次存入树
            CreateTree(treeRoot,one);
        }
        LRD(treeRoot.getTreeRoot());//将结果遍历出来
        System.out.println("author:zsp");
    }
```

  运行截图：

![image-20210702140752427](树的演变/image-20210702140752427.png)