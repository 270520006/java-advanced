# 反射：

### 以前的方式

* 新建一个对象
  Student student = new Student();

* 使用这个对象
  student.study("数学");

### 为什么有反射?（我们不知道这个类里有什么方法，不知道怎么使用它。
* 程序运行过程：编译期(写完代码，进行编译——javac)&运行期（服务已经运行了。。。)

* 答:在运行期，根据某种条件，才能确定使用哪个类的对象的时候，我们就会采用反射了。

* 特点：较为灵活，如在策略模式下可以改变某些变量：

  策略模式：https://www.runoob.com/design-pattern/strategy-pattern.html

  * abstract BaseStrategy.execute()

    ```java
    BaseStrategy.execute( ) { 
    //执行某种策略
    }
    ```

    * 满足分享10次——>AStrategy

    * 满足分享30次——>BStrategy

    * 满足分享50次——>CStrategy 

* 利用反射可以修改里面的次数为任意次数，这样可以定制，使其策略变得更加灵活。

### 类加载区别

![反射图](反射图.png)

* 编译期：new一个对象，编译成class文件，加载到内存，相当于一开始我们就知道了要用的对象的方法了。
* 运行期：不知道要用的对象方法，使用反射去动态打开和检查class文件。

### JVM里类加载的过程

![jvm加载流程图和内存结构](jvm加载流程图和内存结构.png)

* 代码==》class文件==》进行加载五步==》放进jvm

* 因为java的class文件和我们写的代码对于jvm而言是一样的，所以可以使用class文件进行一个反射操作。

### class文件包含的内容

![class文件包含内容](class文件包含内容.png)

* 左边是我们写的代码源码内容，右边是类的信息。

### 生成对象步骤

![image-20210531222417860](反射关键类图.png)

* method：方法 、constructor：构造方法 、field：属性

### 生成对象具体步骤

![生成对象步骤](生成对象步骤.png)

* 正常方式：加载class文件==》查找构造函数==》通过构造函数创建对象

* 使用反射：使用Class.forName得到class文件（第一步一样）==》获取构造函数（第二步也一样）==》创建对象（第三步一样）

  ```java
  Class personClazz1 =Class.forName（"com.zsp.person"）;
  Class personClazz2 =Class.forName（"com.zsp.person"）;
  if(personClazz1 == personClazz2)?是否相等？相等，因为class文件只有一个
  ```

经过比较后会发现二者基本相同，不同的是触发时期和触发点不同：正常new使用是在编译期，使用反射则是在运行期。

### 获得Class对象的方式有几种？ 

* 通过getClass()方式：（需要先new一个对象出来在用）

  ```java
  Class clazz =person.getClass();
  ```
  
* 通过Class.forName：（什么操作都不需要进行）

  ```java
  Class clazz2=Class.forName("com.zsp.Person");
  ```

* 通过.class：（需要先new一个对象进行初始化，初始化完毕后可以去掉对象）

  ```
  Class clazz3 =Person.class;
  ```

  反射获取类对象示例代码：
  
  ```java
  public class ReflectionTest {
      public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
          Class clazz = Class.forName("reflection.Person");  //方法1
  //        Person person = new Person();  //方法2
  //        Class clazz = person.getClass();
  //        Class clazz = Person.class; //方法3
          Constructor constructor1 = clazz.getConstructor();
          Constructor constructor2 = clazz.getConstructor(String.class, int.class, int.class);
          Person person1 = (Person) constructor1.newInstance();
          Person person2 = (Person) constructor2.newInstance("zsp",1,23);
          person1.setName("zsp");
          System.out.println(person1);
          System.out.println(person2);
      }
  }
  ```
  
  