# 反射：

### 以前的方式

* 新建一个对象
  Student student = new Student();

* 使用这个对象
  student.study("数学");

### 为什么有反射?（我们不知道这个类里有什么方法，不知道怎么使用它。
* 程序运行过程：编译期(写完代码，进行编译——javac)&运行期（服务已经运行了。。。)

* 答:在运行期，根据某种条件，才能确定使用哪个类的对象的时候，我们就会采用反射了。

* 特点：较为灵活，如在策略模式下可以改变某些变量：

  策略模式：https://www.runoob.com/design-pattern/strategy-pattern.html

  * abstract BaseStrategy.execute()

    ```java
    BaseStrategy.execute( ) { 
    //执行某种策略
    }
    ```

    * 满足分享10次——>AStrategy

    * 满足分享30次——>BStrategy

    * 满足分享50次——>CStrategy 

* 利用反射可以修改里面的次数为任意次数，这样可以定制，使其策略变得更加灵活。

### 类加载区别

![反射图](C:\Users\Administrator\Desktop\笔记\java-advanced\01.反射、泛型、集合容器\反射图.png)

* 编译期：new一个对象，编译成class文件，加载到内存，相当于一开始我们就知道了要用的对象的方法了。
* 运行期：不知道要用的对象方法，使用反射去动态打开和检查class文件。

### JVM里类加载的过程

![jvm加载流程图和内存结构](C:\Users\Administrator\Desktop\笔记\java-advanced\01.反射、泛型、集合容器\jvm加载流程图和内存结构.png)

* 代码==》class文件==》进行加载五步==》放进jvm

* 因为java的class文件和我们写的代码对于jvm而言是一样的，所以可以使用class文件进行一个反射操作。

### class文件包含的内容

![class文件包含内容](C:\Users\Administrator\Desktop\笔记\java-advanced\01.反射、泛型、集合容器\class文件包含内容.png)

* 左边是我们写的代码源码内容，右边是类的信息。

### 生成对象步骤

![image-20210531222417860](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210531222417860.png)

* method：方法 、constructor：构造方法 、field：属性

### 生成对象具体步骤

![生成对象步骤](C:\Users\Administrator\Desktop\笔记\java-advanced\01.反射、泛型、集合容器\生成对象步骤.png)

* 正常方式：加载class文件==》查找构造函数==》通过构造函数创建对象

* 使用反射：使用Class.forName得到class文件（第一步一样）==》获取构造函数（第二步也一样）==》创建对象（第三步一样）

  ```java
  Class personClazz1 =Class.forName（"com.zsp.person"）;
  Class personClazz2 =Class.forName（"com.zsp.person"）;
  if(personClazz1 == personClazz2)?是否相等？相等，因为class文件只有一个
  ```

经过比较后会发现二者基本相同，不同的是触发时期和触发点不同：正常new使用是在编译期，使用反射则是在运行期。