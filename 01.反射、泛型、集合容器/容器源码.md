---
title: 容器源码
tags: java进阶
hide: true
categories: java进阶
top_img: /images/material/高坂穗乃果.jpg
cover: /images/material/高坂穗乃果.jpg
date: 2021-06-11 16:46:12
---





# 题容器源码

温馨提醒：idea的进入源码只要点击鼠标滑轮，返回上级只要输入Ctrl+alt+←

### ArrayList：

* 底层数据结构：数组，没什么好说的，后续比如链表或者红黑树，我会细讲。

```java
   public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//（值为空{}，空数组）
    } 
```

#### Add方法：（面试可以秀一下grow过程）

* 第一次新增元素，minCapacity=size+1=0+1=1（size初始为0）

```java
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // size初始为0
        elementData[size++] = e;
        return true;
    }
```

* 点击ensureCapacityInternal再往底层
  * （elementData、DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个对象数组，初始为空）
  * DEFAULT_CAPACITY初始为10，可以说是初始容量，（但不是在这里决定的

```java
 private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            //如果这是第二个元素放入，则不会进入判断而是直接返回minCapacity大小的容量
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  //取出最大值，此时minCapacity=10
        }
        ensureExplicitCapacity(minCapacity);
    }
```

* 在进入ensureExplicitCapacity方法里查看
  * modCount初始为0，并且被**transient**修饰，保证不参与序列化和反序列化。是一个计数器，记录ArrayList进行add和remove的次数。

```java
private void ensureExplicitCapacity(int minCapacity) {
        modCount++;   						//记录add和remove操作次数
        // overflow-conscious code
        if (minCapacity - elementData.length > 0)   //elementData初始为0代表原有数组，minCapacity初始为10 
            grow(minCapacity);
    }
```

* ArrayList扩容
  * oldCapacity代表原来数组长度：旧的数组长度
  * newCapacity代表新生成的数组长度：旧的数组长度+旧的数组长度右移一位
  * MAX_ARRAY_SIZE：Integer的最大长度-8（减去8是因为jvm运行需要一些头字，大小为8）

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;  //拿到原来数组
    int newCapacity = oldCapacity + (oldCapacity >> 1); //>>代表右移，右移移位相当于除2，所以整体长度为1.5倍原数组
    if (newCapacity - minCapacity < 0) //如果新的数组长度小于minCapacity长度（初始为size+1，为1，后面变为10）
        newCapacity = minCapacity;  //扩容长度变为初始容量10
    if (newCapacity - MAX_ARRAY_SIZE > 0) //怕超过数字的最大容量-8，为什么减去8，因为jvm会保存一些头字，这些为8
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

* 进入hugeCapacity源码继续查看

```java
	private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow  //为什么超过了Integer最大长度-8还会小于0，因为溢出了二进制最大值
            throw new OutOfMemoryError(); //OOM异常
        return (minCapacity > MAX_ARRAY_SIZE) ?	Integer.MAX_VALUE :MAX_ARRAY_SIZE;
        //如果没有溢出，则妥协 返回Integer最大长度给她
    }
```

* 最后使用copyOf，将旧数组的值赋值给新数组

```java
 elementData = Arrays.copyOf(elementData, newCapacity);
```

* 最后再返回add方法里，将索引挪到下一位，然后把元素添加进去

```java
  elementData[size++] = e;
        return true;
```

#### Get方法：

* get方法进入

```java
   public E get(int index) {
        rangeCheck(index);  //进入判断索引有没有超过数组最大长度
        return elementData(index);
    }

```

* 进入rangeCheck方法

```java
    private void rangeCheck(int index) {
        if (index >= size)  //索引不能超过数组最大值，否则异常
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
```

* 进入elementData方法
  * 这里面的E就是T，泛型

```java
    E elementData(int index) {
        return (E) elementData[index];  //从elementData数组中取值返回
    }
```

#### Remove方法：(面试可以秀一下arraycopy过程)

* remove方法是通过元素移动来实现的，先提取出要移动的元素，然后进行移动，最后将其值赋为空，jvm会帮我们自动处理数组内值为null的元素。 

```java
public E remove(int index) {       //默认数组为{a1,a2,a3,a4,a5}
    rangeCheck(index); 
    modCount++; //计数器，记录add和remove了几次操作
    E oldValue = elementData(index); //从数组中取出索引对应元素
    int numMoved = size - index - 1; //记录要移动的元素个数，例如你删除的元素索引值为“2”,则得到2
    if (numMoved > 0)				//当要移动的值大于0，因为有可能删除的是最后一个元素，就没有移动的元素
        System.arraycopy(elementData, index+1, elementData, index,numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
```

* rangeCheck：检查索引是否超过数组范围

```java
   private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
```

* System.arraycopy：是一个本地方法，下面方法运行过程
  * 默认数组为{a1,a2,a3,a4,a5},删除了a3，此时numMoved=2，要移动2个元素。
  * 第一个传入数组是原数组，从index+1（a4）开始复制numMoved位（2位）带第二个elementData的第三个位置中（原本a3位置）
  * 最终得到的数组是{a1,a2,a4,a5,a5}

```java
  public static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);
 //下面是从remove里抠下来的方便解释
//
  System.arraycopy(elementData, index+1, elementData, index,numMoved);
```

* 最终将最后一个元素赋值为null，让JVM的GC帮我们处理空值，结果为{a1,a2,a4,a5}

```java
  elementData[--size] = null; // clear to let GC do its work
    return oldValue;
```

### LinkedList

#### 底层数据结构

LinkedList底层数据结构：双向链表（每个队列都有独立的前置结点指针+后置结点指针+元素）

```java
    private static class Node<E> {
        E item;  //队列存储的元素
        Node<E> next;  //后置结点指针
        Node<E> prev;	//前置结点指针
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element; //传入的元素
            this.next = next;   //后置结点指针
            this.prev = prev;    //前置结点指针
        }
    }
```

单向链表：只有next，作为后置结点指针，指向下个结点。

双向链表：next和prev都有，一个指针指向后置结点，另一个指向前置结点。

![链表数据结构](容器源码/链表数据结构.png)

#### Add方法：

* 将传入元素传递给linkLast方法：

```java
    public boolean add(E e) {
        linkLast(e);
        return true; //插入无需判断越界，所以直接返回true
    }
```

* 进入linkLast方法：
  * node是什么，前面刚开始介绍了。
  * last也是一个Node类，初始值为空，表示上个结点：transient Node<E> last;
  * fist也是一个Node类，初始值为空，表示第一个结点：transient Node<E> first;

```java
    void linkLast(E e) {
        final Node<E> l = last; //l表示上个结点，如果为第一个则为null
        final Node<E> newNode = new Node<>(l, e, null); 
        //传入一个新的结点后，前置结点就是链表以前的最后一个结点，后置结点为空
        last = newNode; //最后一个结点变为新的结点
        if (l == null) //如果l为空说明现在传入的是链表的第一个结点
            first = newNode; //第一个结点变为新传入的结点
        else  //否则上个结点的下置结点变为当前传入的新节点
            l.next = newNode;
        size++;  //大小+1
        modCount++;   //统计进行了多少次add和remove
    }
```

第一个元素插入：

![image-20210620114419054](容器源码/image-20210620114419054.png)

往后的元素插入：

![image-20210620114902616](容器源码/image-20210620114902616.png)

#### Get方法

* 进入方法内部，主要先判断长度有没有越界，没有就取值出来。

```java
public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}
```

* 进入checkElementIndex方法内部：判断传入的index是否超过固有长度。

```java
    private void checkElementIndex(int index) {
        if (!isElementIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

```

* 再进入isElementIndex：发现是拿add方法中的size和index。

```java
   private boolean isElementIndex(int index) {
        return index >= 0 && index < size;
    }
```

#### Remove方法：

* 进入方法内部，和get方法一样先判断是否越界，这里不再赘述。

```java
    public E remove(int index) {
        checkElementIndex(index);
        return unlink(node(index));//传入索引查出结点，而后把结点放入unlink方法中
    }
```

* 进入node方法，查看取出结点过程。
  * index < (size >> 1)：判断索引是大于还是小于长度的一半。
    * 大于就从头遍历,找到目标结点的上一个结点的后置节点指针，根据指针得到对应结点。
    * 小于就从尾遍历,找到目标结点的下一个结点的前置节点指针，根据指针得到对应结点。

```java
    Node<E> node(int index) {
        // assert isElementIndex(index);
        if (index < (size >> 1)) { //判断索引是大于还是小于长度的一半，大于就从头遍历
            Node<E> x = first;
            for (int i = 0; i < index; i++) //
                x = x.next;
            return x;
        } else {  //小于就从尾巴开始遍历
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
```

* 进入unlink方法：有点多，但是不要怕，看注释，一步步都写好了。

```java
    E unlink(Node<E> x) {
        // assert x != null;
        final E element = x.item;
        final Node<E> next = x.next;
        final Node<E> prev = x.prev;
		//刚开始把传入的结点全部取出
        if (prev == null) { //如果前置结点指针为空，说明这个是第一个结点
            first = next;  //把首结点标记给到下一个结点
        } else {			//否则， 说明不是首结点
            prev.next = next; //把前置结点的后置指针指向删除的结点的下个结点
            x.prev = null; //把要删除结点的前置指针置为空
        }

        if (next == null) { //如果要删除的后置结点指针为空，说明最后一个结点
            last = prev; //把尾结点的标记给到下一个结点
        } else { //否则，说明不是尾结点
            next.prev = prev;//把后置结点的前置指针指向要删除的结点的上个结点
            x.next = null;//把要删除结点的后置指针置为空
        }
        x.item = null; //把要删除结点的值置为空
        size--; //长度减少1
        modCount++; //操作次数+1，remove和add都会增加modCount的次数
        return element; //返回这个结点的值，以置空
    }
```

### Hashmap

​	底层数据结构：JDK1.7散列表（数组+链表），JDK1.8数组+链表/红黑树，这里我详细给大家介绍一下，当然想了解树的演变过程可以看我的下一篇文章。下面，先说下术语，然后在开始讲数据结构：

#### 术语：先给大家解释下术语，防止看不懂

​    这里说一下桶，网上大部分博客意见不一，有的把数组叫做桶，有的把整个数组和链表叫做桶，个人拙见，桶应该是单个数组对应的链表称之为桶：

* 桶：就是这一条，看图，是一个数组里的元素和对应的一条链表，两个合起来称之为桶。
* 桶长：是这个数组里的某个元素对应的链表长度。
* 位桶：这个数组。

![1624430400201](容器源码/1624430400201.png)

#### 底层数据结构

##### 散列表

先带大家认识下散列表，散列表就是数组+链表：

* 当数据进入时，会先拿到该元素的hash值给到数组，然后再有相同的hash值的数据进入到数组中的话，就会进行哈希碰撞，碰撞有两个方法（拉链法和开放定址法）。
  * 拉链法：当一个元素存储进散列表的时候，会先计算哈希值，然后放到数组里。遇到下一个放进来的元素和它的哈希值相同，就放到相同的链表里。
  * 开放定址法：当一个元素存储进散列表的时候，会先计算哈希值，然后放到数组里。遇到下一个放进来的元素和它的哈希值相同，就放到这个元素的下一个数组里(所以这个方法和底下这个图不匹配，不用看了)。

![1624429702119](容器源码/1624429702119.png)

##### 红黑树

  hashmap无非就是数组+链表（JDK1.7）或者数组+链表/红黑树（JDK1.8)散列表已经说完了，下面讲一讲红黑树，可能入门有点难度，如果看不懂的话，可以先看我的文章《树的演变》：

  首先红黑树先记下来五个特点：

* 每个节点或者是黑色，或者是红色。
* 根节点是黑色。
* 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
* 如果一个节点是红色的，则它的子节点必须是黑色的。
* 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

注意：

* 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
*  特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

  这里解释下什么是 nil、Nil、NULL、NSNull （不区分大小写）：

```java
nil：指向一个对象的空指针,对objective c id 对象赋空值.
Nil：指向一个类的空指针,表示对类进行赋空值.
NULL：指向其他类型（如：基本类型、C类型）的空指针, 用于对非对象指针赋空值.
NSNull：在集合对象中，表示空值的对象.
```

 以下是对应五个特点画出来的红黑树图：画的不好看，见谅。。。

![img](容器源码/NP9ET[9]NZ4LM30NM[YTNXA.png) 

  任何用来存储的数据结构，最主要的还是**添加**、**删除**。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。
  旋转包括两种：**左旋** 和 **右旋**。下面分别对它们进行介绍。 

###### 左旋

步骤如下：（左旋左子树，改变左子树，并变成左子树）

* 先将Y的｛左｝子树给X。
* 将X父亲给Y ，这时候有三种情况，如图所示。
* 最后完成了左旋。

![左旋 ](容器源码/左旋 .jpg)

###### 右旋

步骤如下：（右旋,改变右子树，并变成右子树）

* 先将X的｛右｝子树给Y。
* 将Y父亲给X ，这时候有三种情况，如图所示。
* 最后完成了右旋。

![右旋](容器源码/右旋.jpg)

足够细心的话会发现，左右旋是对称的，即左旋以后再右旋就能回到原本的样子。

* 左旋就提旋转目标的右子树上去，使自身变成右子树。
* 右旋就提旋转目标的左子树上去，使自身变成左子树。

   举例：以下都以X为旋转目标：

![image-20210623203807844](容器源码/image-20210623203807844.png)

![image-20210623203819697](容器源码/image-20210623203819697.png)

这一块想看代码可以看我的《树的演变》一章，里面会详细告诉大家，树的相关操作的所有代码。

###### 添加

下去这部分可能有点难度，大家跟好车，先看一下这部分伪代码：这里我们是要插入z，然后在节点Y下插入的。

```java
RB-INSERT(T, z)  
  y ← nil[T]                        // 新建节点“y”，将y设为空节点。
  x ← root[T]                       // 设“红黑树T”的根节点为“x”
  while x ≠ nil[T]                  // 找出要插入的节点“z”在二叉树T中的位置“y”
      do y ← x                      
         if key[z] < key[x]  
            then x ← left[x]  
            else x ← right[x]  
  p[z] ← y                          // 设置 “z的父亲” 为 “y”
  if y = nil[T]                     
     then root[T] ← z               // 情况1：若y是空节点，则将z设为根
     else if key[z] < key[y]        
             then left[y] ← z       // 情况2：若“z所包含的值” < “y所包含的值”，则将z设为“y的左孩子”
             else right[y] ← z      // 情况3：(“z所包含的值” >= “y所包含的值”)将z设为“y的右孩子” 
  left[z] ← nil[T]                  // z的左孩子设为空
  right[z] ← nil[T]                 // z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。
  color[z] ← RED                    // 将z着色为“红色”
  RB-INSERT-FIXUP(T, z)             // 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树
```

